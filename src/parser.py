'''
Log parsing functionality - Developer: Koen Aerts
'''
import os
import struct
import math
import datetime
import re

from enums import MotorStatus, DroneStatus, FlightMode, PositionMode

from kivy_garden.mapview.utils import haversine


class AtomBaseLogParser():

    def __init__(self, parent):
        self.parent = parent
        self.db = parent.db
        self.common = parent.common


    def parse(self, importRef):
        '''
        Parse Atom based logs.
        '''
        self.parent.zipFilename = importRef
        fpvFiles = self.db.execute("SELECT filename FROM log_files WHERE importref = ? AND bintype = 'FPV' ORDER BY filename", (importRef,))
        binFiles = self.db.execute("SELECT filename FROM log_files WHERE importref = ? AND bintype IN ('BIN','FC') ORDER BY filename", (importRef,))

        # First read the FPV file. The presence of this file is optional. The format of this
        # file differs slightly based on the mobile platform it was created on: Android vs iOS.
        # Example filenames:
        #   - 20230819190421-AtomSE-iosSystem-iPhone13Pro-FPV.bin
        #   - 20230826161313-Atom SE-Android-(samsung)-FPV.bin
        fpvStat = {}
        for fileRef in fpvFiles:
            file = fileRef[0]
            with open(os.path.join(self.parent.logfileDir, file), mode='rb') as fpvFile:
                while True:
                    fpvRecord = fpvFile.readline().decode("utf-8")
                    if not fpvRecord:
                        break
                    reclen = len(fpvRecord)
                    if (reclen == 19):
                        binval = fpvRecord[15:18].encode("ascii")
                        hex1 = ('0' + hex(binval[0])[2:])[-2:]
                        hex2 = ('0' + hex(binval[1])[2:])[-2:]
                        hex3 = ('0' + hex(binval[2])[2:])[-2:]
                        fpvStat[fpvRecord[:14]] = f'00{hex1}{hex2}{hex3}' # iOS
                    elif (reclen == 24):
                        fpvStat[fpvRecord[:14]] = fpvRecord[15:] # Android
            fpvFile.close()

        timestampMarkers = []

        # First grab timestamps from the filenames. Those are used to calculate the real timestamps with the elapsed time from each record.
        for fileRef in binFiles:
            file = fileRef[0]
            timestampMarkers.append(datetime.datetime.strptime(re.sub("-.*", "", file), '%Y%m%d%H%M%S'))

        if len(timestampMarkers) == 0:
            # Code should not get here, unless empty files were imported in older versions of this app.
            self.parent.show_warning_message(message=_('no_data_in_zip_file'))
            return

        filenameTs = timestampMarkers[0]
        prevReadingTs = timestampMarkers[0]
        firstTs = None
        distTraveled = 0
        self.parent.pathCoords = []
        self.parent.flightStarts = {}
        self.parent.flightEnds = {}
        self.parent.flightStats = []
        pathCoord = []
        isNewPath = True
        isFlying = False
        recordCount = 0
        tableLen = 0
        for fileRef in binFiles:
            file = fileRef[0]
            with open(os.path.join(self.parent.logfileDir, file), mode='rb') as flightFile:
                while True:
                    fcRecord = flightFile.read(512)
                    if (len(fcRecord) < 512):
                        break

                    recordCount = recordCount + 1
                    recordId = struct.unpack('<I', fcRecord[0:4])[0] # This incremental record count is generated by the Potensic Pro app. All other fields are generated directly on the drone itself. The Potensic App saves these drone logs to the .bin files on the mobile device.
                    elapsed = struct.unpack('<Q', fcRecord[5:13])[0] # Microseconds elapsed since previous reading.
                    if (elapsed == 0):
                        continue # handle rare case of invalid record
                    isLegacyLog = struct.unpack('<B', fcRecord[509:510])[0] == 0 and struct.unpack('<B', fcRecord[510:511])[0] == 0 and struct.unpack('<B', fcRecord[511:512])[0] == 0
                    offset1 = 0
                    offset2 = 0
                    offset3 = 0
                    if not isLegacyLog: # 0,0,0 = legacy, 3,3,0 = new
                        offset1 = -6
                        offset2 = -10
                        offset3 = -14
                    flightCounter = struct.unpack('<H', fcRecord[17:19])[0] # Drone's flight counter. Increments each time it initiates a new flight.
                    satellites = struct.unpack('<B', fcRecord[46:47])[0] # Number of satellites.
                    dronelat = struct.unpack('<i', fcRecord[53+offset1:57+offset1])[0]/10000000 # Drone coords.
                    dronelon = struct.unpack('<i', fcRecord[57+offset1:61+offset1])[0]/10000000
                    ctrllat = struct.unpack('<i', fcRecord[159+offset2:163+offset2])[0]/10000000 # Controller coords.
                    ctrllon = struct.unpack('<i', fcRecord[163+offset2:167+offset2])[0]/10000000
                    homelat = struct.unpack('<i', fcRecord[435+offset2:439+offset2])[0]/10000000 # Home Point coords (for Return To Home).
                    homelon = struct.unpack('<i', fcRecord[439+offset2:443+offset2])[0]/10000000
                    dist1lat = self.common.dist_val(struct.unpack('f', fcRecord[235+offset2:239+offset2])[0]) # Distance home point vs controller??
                    dist1lon = self.common.dist_val(struct.unpack('f', fcRecord[239+offset2:243+offset2])[0])
                    dist2lat = self.common.dist_val(struct.unpack('f', fcRecord[319+offset2:323+offset2])[0]) # Distance home point vs controller??
                    dist2lon = self.common.dist_val(struct.unpack('f', fcRecord[323+offset2:327+offset2])[0])
                    dist1 = round(math.sqrt(math.pow(dist1lat, 2) + math.pow(dist1lon, 2)), 2) # Pythagoras to calculate real distance.
                    dist2 = round(math.sqrt(math.pow(dist2lat, 2) + math.pow(dist2lon, 2)), 2) # Pythagoras to calculate real distance.
                    dist3metric = struct.unpack('f', fcRecord[431+offset2:435+offset2])[0]# Distance from home point, as reported by the drone.
                    dist3 = self.common.dist_val(dist3metric)
                    gps = struct.unpack('f', fcRecord[279+offset2:283+offset2])[0] # GPS (-1 = no GPS, 0 = GPS ready, 2 and up = GPS in use)
                    gpsStatus = 'Yes' if gps >= 0 else 'No'
                    #sdff = (special - 2) * 4 * 60 * 1000
                    #elms = 0 if sdff < 0 else datetime.timedelta(milliseconds=sdff) # possibly elapsed flight time??
                    #flightCount = struct.unpack('<B', fcRecord[303+offset2:304+offset2])[0] # Some sort of counter.
                    #spec4 = struct.unpack('<B', fcRecord[304+offset2:305+offset2])[0] # ?
                    #spec5 = struct.unpack('<B', fcRecord[305+offset2:306+offset2])[0] # ?
                    #spec6 = struct.unpack('<B', fcRecord[306+offset2:307+offset2])[0] # ?
                    #spec7 = struct.unpack('<B', fcRecord[307+offset2:308+offset2])[0] # ?
                    motor1Stat = struct.unpack('<B', fcRecord[312+offset2:313+offset2])[0] # Motor 1 speed (3 = off, 4 = idle, 5 = low, 6 = medium, 7 = high)
                    motor2Stat = struct.unpack('<B', fcRecord[314+offset2:315+offset2])[0] # Motor 2 speed (3 = off, 4 = idle, 5 = low, 6 = medium, 7 = high)
                    motor3Stat = struct.unpack('<B', fcRecord[316+offset2:317+offset2])[0] # Motor 3 speed (3 = off, 4 = idle, 5 = low, 6 = medium, 7 = high)
                    motor4Stat = struct.unpack('<B', fcRecord[318+offset2:319+offset2])[0] # Motor 4 speed (3 = off, 4 = idle, 5 = low, 6 = medium, 7 = high)
                    droneInUse = struct.unpack('<B', fcRecord[295+offset2:296+offset2])[0] # Drone is detected "in action" (0 = flying or in use, 1 = not in use).
                    droneConnected = struct.unpack('<B', fcRecord[469+offset3:470+offset3])[0] # Drone connected to controller, 1 = Yes, 0 = No.
                    batteryLevel = struct.unpack('<B', fcRecord[481+offset3:482+offset3])[0] # Battery level.
                    batteryTemp = struct.unpack('<B', fcRecord[476+offset3:477+offset3])[0] # Battery temperature (celcius).
                    batteryCurrent = -struct.unpack('<h', fcRecord[474+offset3:476+offset3])[0] # Battery current (mA).
                    batteryVoltage1 = struct.unpack('<h', fcRecord[470+offset3:472+offset3])[0]/1000 # Battery voltage 1
                    batteryVoltage2 = struct.unpack('<h', fcRecord[472+offset3:474+offset3])[0]/1000 # Battery voltage 2
                    batteryVoltage = batteryVoltage1 + batteryVoltage2
                    flightMode = struct.unpack('<B', fcRecord[448+offset2:449+offset2])[0] # Flight mode: normal, video, sports.
                    flightModeDesc = FlightMode.VIDEO.value if flightMode == 7 else FlightMode.NORMAL.value if flightMode == 8 else FlightMode.SPORT.value if flightMode == 9 else ''
                    droneAction = struct.unpack('<B', fcRecord[486+offset3:487+offset3])[0] # Drone action: 0 = motors off, 1 = grounded or taking off, 2 = flying, 3 = landing. # Field @ offset 443 looks the same?
                    rth = 0 if droneAction != 2 else struct.unpack('<B', fcRecord[444+offset2:445+offset2])[0] # Home or Return to Home, 1 = Yes, 0 = No.
                    positionMode = struct.unpack('<B', fcRecord[487+offset3:488+offset3])[0] # Unidentified - GPS/ATTI mode? Almost the same @ offset 445
                    inUse = 'Yes' if droneInUse == 0 else 'No'
                    posModeDesc = PositionMode.GPS.value if positionMode == 3 else PositionMode.OPTI.value if positionMode == 2 else positionMode # TODO - don't know value yet for ATTI, probably 1??

                    alt1 = round(self.common.dist_val(-struct.unpack('f', fcRecord[243+offset2:247+offset2])[0]), 2) # Relative height from controller vs distance to ground??
                    alt2metric = -struct.unpack('f', fcRecord[343+offset2:347+offset2])[0] # Relative height from controller vs distance to ground??
                    alt2 = round(self.common.dist_val(alt2metric), 2)
                    speed1lat = self.common.speed_val(struct.unpack('f', fcRecord[247+offset2:251+offset2])[0])
                    speed1lon = self.common.speed_val(struct.unpack('f', fcRecord[251+offset2:255+offset2])[0])
                    speed2latmetric = struct.unpack('f', fcRecord[327+offset2:331+offset2])[0]
                    speed2lat = self.common.speed_val(speed2latmetric)
                    speed2lonmetric = struct.unpack('f', fcRecord[331+offset2:335+offset2])[0]
                    speed2lon = self.common.speed_val(speed2lonmetric)
                    # Offset 335 + 339 (float)
                    # Offset 351 + 355 (float)
                    # Offset 371 + 375 (float)
                    speed1 = round(math.sqrt(math.pow(speed1lat, 2) + math.pow(speed1lon, 2)), 2) # Pythagoras to calculate real speed.
                    speed2metric = round(math.sqrt(math.pow(speed2latmetric, 2) + math.pow(speed2lonmetric, 2)), 2)
                    speed2 = round(math.sqrt(math.pow(speed2lat, 2) + math.pow(speed2lon, 2)), 2) # Pythagoras to calculate real speed.
                    speed1vert = self.common.speed_val(-struct.unpack('f', fcRecord[255+offset2:259+offset2])[0])
                    speed2vertmetric = -struct.unpack('f', fcRecord[347+offset2:351+offset2])[0] # Vertical speed
                    speed2vertmetricabs = abs(speed2vertmetric)
                    speed2vert = self.common.speed_val(speed2vertmetric)
                    orientation1 = struct.unpack('f', fcRecord[175+offset2:179+offset2])[0] # Drone orientation in radians. Seems to slightly differ from orientation2... not sure why. Yaw??
                    orientation2 = struct.unpack('f', fcRecord[391+offset2:395+offset2])[0] # Drone orientation in radians.
                    roll = struct.unpack('f', fcRecord[383+offset2:387+offset2])[0] # Roll - TODO: need to confirm still
                    winddirection = struct.unpack('f', fcRecord[423+offset2:427+offset2])[0] # Wind Direction - TODO: need to confirm still

                    # Some checks to handle cases with bad or incomplete GPS data.
                    hasDroneCoords = dronelat != 0.0 and dronelon != 0.0
                    hasCtrlCoords = ctrllat != 0.0 and ctrllon != 0.0
                    hasHomeCoords = homelat != 0.0 and homelon != 0.0
                    sanDist = 0
                    if (hasDroneCoords and hasHomeCoords):
                        try:
                            sanDist = haversine(homelon, homelat, dronelon, dronelat)
                        except:
                            sanDist = 9999
                    elif (hasDroneCoords and hasCtrlCoords):
                        try:
                            sanDist = haversine(ctrllon, ctrllat, dronelon, dronelat)
                        except:
                            sanDist = 9999

                    hasValidCoords = sanDist < 20 and hasDroneCoords and (hasCtrlCoords or hasHomeCoords)

                    droneMotorStatus = MotorStatus.UNKNOWN
                    if motor1Stat > 4 or motor2Stat > 4 or motor3Stat > 4 or motor4Stat > 4:
                        droneMotorStatus = MotorStatus.LIFT
                    elif motor1Stat == 4 or motor2Stat == 4 or motor3Stat == 4 or motor4Stat == 4:
                        droneMotorStatus = MotorStatus.IDLE
                    elif motor1Stat == 3 and motor2Stat == 3 and motor3Stat == 3 and motor4Stat == 3:
                        droneMotorStatus = MotorStatus.OFF
                    statusChanged = False
                    if isFlying:
                        if droneMotorStatus == MotorStatus.OFF:
                            isFlying = False
                            statusChanged = True
                            firstTs = None
                            distTraveled = 0
                    elif droneMotorStatus == MotorStatus.LIFT:
                        isFlying = True
                        statusChanged = True
                    else:
                        firstTs = None
                        distTraveled = 0

                    droneActionDesc = DroneStatus.UNKNOWN
                    if droneAction == 0:
                        droneActionDesc = DroneStatus.OFF
                    elif droneAction == 1 and droneMotorStatus == MotorStatus.IDLE:
                        droneActionDesc = DroneStatus.IDLE
                    elif droneAction == 1 and droneMotorStatus == MotorStatus.LIFT:
                        droneActionDesc = DroneStatus.LIFT
                    elif droneAction == 2:
                        droneActionDesc = DroneStatus.FLYING
                    elif droneAction == 3:
                        droneActionDesc = DroneStatus.LANDING

                    # Calculate timestamp for the record.
                    readingTs = filenameTs + datetime.timedelta(milliseconds=(elapsed/1000))
                    while (readingTs < prevReadingTs):
                        # Line up to the next valid timestamp marker (pulled from the filenames).
                        try:
                            filenameTs = timestampMarkers.pop(0)
                            readingTs = filenameTs + datetime.timedelta(milliseconds=(elapsed/1000))
                        except:
                            # Handle rare case where log files contain mismatched "elapsed" indicators and times in bin filenames.
                            readingTs = prevReadingTs

                    # Calculate elapsed time for the flight.
                    if firstTs is None:
                        firstTs = readingTs
                    elapsedTs = readingTs - firstTs
                    elapsedTsRounded = elapsedTs - datetime.timedelta(microseconds=elapsedTs.microseconds) # truncate to milliseconds
                    prevReadingTs = readingTs

                    # Build paths for each flight and keep metric summaries of each path (flight), as well as for the entire log file.
                    pathNum = 0
                    if pathNum == len(self.parent.flightStats):
                        self.parent.flightStats.append([dist3metric, alt2metric, speed2metric, None, dronelat, dronelon, dronelat, dronelon, speed2vertmetricabs, None])
                    else:
                        if dist3metric > self.parent.flightStats[pathNum][0]: # Overall Max distance
                            self.parent.flightStats[pathNum][0] = dist3metric
                        if alt2metric > self.parent.flightStats[pathNum][1]: # Overall Max altitude
                            self.parent.flightStats[pathNum][1] = alt2metric
                        if speed2metric > self.parent.flightStats[pathNum][2]: # Overall Max speed
                            self.parent.flightStats[pathNum][2] = speed2metric
                        if dronelat < self.parent.flightStats[pathNum][4]: # Overall Min latitude
                            self.parent.flightStats[pathNum][4] = dronelat
                        if dronelon < self.parent.flightStats[pathNum][5]: # Overall Min longitude
                            self.parent.flightStats[pathNum][5] = dronelon
                        if dronelat > self.parent.flightStats[pathNum][6]: # Overall Max latitude
                            self.parent.flightStats[pathNum][6] = dronelat
                        if dronelon > self.parent.flightStats[pathNum][7]: # Overall Max longitude
                            self.parent.flightStats[pathNum][7] = dronelon
                        if speed2vertmetricabs > self.parent.flightStats[pathNum][8]: # Vertical Max speed (could be up or down)
                            self.parent.flightStats[pathNum][8] = speed2vertmetricabs
                    if (hasValidCoords):
                        if (statusChanged): # start new flight path if current one ends or new one begins.
                            if (len(pathCoord) > 0):
                                self.parent.pathCoords.append(pathCoord)
                                pathCoord = []
                                isNewPath = True
                        if (isFlying): # Only trace path when the drone's motors are spinning faster than idle speeds.
                            pathNum = len(self.parent.pathCoords)+1
                            if len(pathCoord) == 0:
                                pathCoord.append([])
                            lastSegment = pathCoord[len(pathCoord)-1]
                            lastCoord = lastSegment[len(lastSegment)-1] if len(lastSegment) > 0 else [9999, 9999]
                            if lastCoord[0] != dronelon or lastCoord[1] != dronelat: # Only include the point if it is different from the previous (i.e. drone moved)
                                if len(lastSegment) >= 200: # Break flight paths into segments because the map widget cannot handle too many points per path otherwise.
                                    lastCoord = lastSegment[len(lastSegment)-1]
                                    pathCoord.append([])
                                    lastSegment = pathCoord[len(pathCoord)-1]
                                    lastSegment.append(lastCoord)
                                lastSegment.append([dronelon, dronelat])
                                if lastCoord[0] != 9999:
                                    distTraveled = distTraveled + (haversine(lastCoord[0], lastCoord[1], dronelon, dronelat) * 1000)
                            if pathNum == len(self.parent.flightStats):
                                self.parent.flightStats.append([dist3metric, alt2metric, speed2metric, elapsedTs, dronelat, dronelon, dronelat, dronelon, speed2vertmetricabs, distTraveled])
                            else:
                                if dist3metric > self.parent.flightStats[pathNum][0]: # Flight Max distance
                                    self.parent.flightStats[pathNum][0] = dist3metric
                                if alt2metric > self.parent.flightStats[pathNum][1]: # Flight Max altitude
                                    self.parent.flightStats[pathNum][1] = alt2metric
                                if speed2metric > self.parent.flightStats[pathNum][2]: # Flight Horizontal Max speed
                                    self.parent.flightStats[pathNum][2] = speed2metric
                                self.parent.flightStats[pathNum][3] = elapsedTsRounded # Flight duration
                                if dronelat < self.parent.flightStats[pathNum][4]: # Flight Min latitude
                                    self.parent.flightStats[pathNum][4] = dronelat
                                if dronelon < self.parent.flightStats[pathNum][5]: # Flight Min longitude
                                    self.parent.flightStats[pathNum][5] = dronelon
                                if dronelat > self.parent.flightStats[pathNum][6]: # Flight Max latitude
                                    self.parent.flightStats[pathNum][6] = dronelat
                                if dronelon > self.parent.flightStats[pathNum][7]: # Flight Max longitude
                                    self.parent.flightStats[pathNum][7] = dronelon
                                if speed2vertmetricabs > self.parent.flightStats[pathNum][8]: # Vertical Max speed (could be up or down)
                                    self.parent.flightStats[pathNum][8] = speed2vertmetricabs
                                self.parent.flightStats[pathNum][9] = distTraveled # Distance Travelled

                    # Get corresponding record from the controller. There may not be one, or any at all. Match up to 5 seconds ago.
                    fpvRssi = ""
                    fpvChannel = ""
                    #fpvWirelessConnected = ""
                    fpvFlightCtrlConnected = ""
                    fpvRemoteConnected = ""
                    #fpvHighDbm = ""
                    fpvRecord = fpvStat.get(readingTs.strftime('%Y%m%d%H%M%S'))
                    secondsAgo = -1
                    while (not fpvRecord):
                        fpvRecord = fpvStat.get((readingTs + datetime.timedelta(seconds=secondsAgo)).strftime('%Y%m%d%H%M%S'))
                        if (secondsAgo <= -5):
                            break
                        secondsAgo = secondsAgo - 1
                    if (fpvRecord):
                        fpvRssi = str(int(fpvRecord[2:4], 16))
                        fpvChannel = str(int(fpvRecord[4:6], 16))
                        fpvFlags = int(fpvRecord[6:8], 16)
                        #fpvWirelessConnected = "1" if fpvFlags & 1 == 1 else "0"
                        fpvFlightCtrlConnected = "1" if fpvFlags & 2 == 2 else "0" # Drone to controller connection.
                        fpvRemoteConnected = "1" if fpvFlags & 4 == 4 else "0"
                        #fpvHighDbm = "1" if fpvFlags & 32 == 32 else "0"

                    flightDesc = f'{pathNum}'
                    if (isNewPath and len(pathCoord) > 0):
                        self.parent.flightOptions.append(flightDesc)
                        self.parent.flightStarts[flightDesc] = tableLen
                        isNewPath = False
                    if pathNum > 0:
                        self.parent.flightEnds[flightDesc] = tableLen
                    self.parent.logdata.append([recordCount, recordId, pathNum, readingTs.isoformat(sep=' '), readingTs.strftime('%X'), elapsedTs, f"{self.common.fmt_num(dist1)}", f"{self.common.fmt_num(dist1lat)}", f"{self.common.fmt_num(dist1lon)}", f"{self.common.fmt_num(dist2)}", f"{self.common.fmt_num(dist2lat)}", f"{self.common.fmt_num(dist2lon)}", f"{self.common.fmt_num(dist3)}", f"{self.common.fmt_num(alt1)}", f"{self.common.fmt_num(alt2)}", alt2metric, f"{self.common.fmt_num(speed1)}", f"{self.common.fmt_num(speed1lat)}", f"{self.common.fmt_num(speed1lon)}", f"{self.common.fmt_num(speed2)}", f"{self.common.fmt_num(speed2lat)}", f"{self.common.fmt_num(speed2lon)}", f"{self.common.fmt_num(speed1vert)}", f"{self.common.fmt_num(speed2vert)}", str(satellites), str(ctrllat), str(ctrllon), str(homelat), str(homelon), str(dronelat), str(dronelon), orientation1, orientation2, roll, winddirection, motor1Stat, motor2Stat, motor3Stat, motor4Stat, droneMotorStatus.value, droneActionDesc.value, droneAction, fpvRssi, fpvChannel, fpvFlightCtrlConnected, fpvRemoteConnected, droneConnected, rth, posModeDesc, gpsStatus, inUse, f"{self.common.fmt_num(self.common.dist_val(distTraveled))}", batteryLevel, batteryTemp, batteryCurrent, batteryVoltage, batteryVoltage1, batteryVoltage2, flightModeDesc, flightCounter])
                    tableLen = tableLen + 1

            flightFile.close()

        if (len(pathCoord) > 0):
            self.parent.pathCoords.append(pathCoord)
        dbRows = self.db.execute("""
            SELECT flight_number, duration, max_distance, max_altitude, max_h_speed, max_v_speed, traveled
            FROM flight_stats WHERE importref = ?
            """, (importRef,)
        )
        hasData = dbRows is not None and len(dbRows) > 0
        for i in range(1, len(self.parent.flightStats)):
            if not hasData:
                # These stats are used in the log file list to show metrics for each file.
                self.db.execute("""
                    INSERT INTO flight_stats(importref, flight_number, duration, max_distance, max_altitude, max_h_speed, max_v_speed, traveled)
                    VALUES(?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (importRef, i, self.parent.flightStats[i][3].total_seconds(), self.parent.flightStats[i][0], self.parent.flightStats[i][1], self.parent.flightStats[i][2], self.parent.flightStats[i][8], self.parent.flightStats[i][9])
                )
            if self.parent.flightStats[0][3] == None:
                self.parent.flightStats[0][2] = self.parent.flightStats[i][2] # Flight Horizontal Max speed
                self.parent.flightStats[0][3] = self.parent.flightStats[i][3] # Flight duration (total)
                self.parent.flightStats[0][4] = self.parent.flightStats[i][4] # Flight Min latitude
                self.parent.flightStats[0][5] = self.parent.flightStats[i][5] # Flight Min longitude
                self.parent.flightStats[0][6] = self.parent.flightStats[i][6] # Flight Max latitude
                self.parent.flightStats[0][7] = self.parent.flightStats[i][7] # Flight Max longitude
                self.parent.flightStats[0][8] = self.parent.flightStats[i][8] # Vertical Max speed (could be up or down)
                self.parent.flightStats[0][9] = self.parent.flightStats[i][9] # Distance Travelled (total)
            else:
                self.parent.flightStats[0][3] = self.parent.flightStats[0][3] + self.parent.flightStats[i][3] # Total duration
                if self.parent.flightStats[i][2] > self.parent.flightStats[0][2]: # Flight Horizontal Max speed
                    self.parent.flightStats[0][2] = self.parent.flightStats[i][2]
                if self.parent.flightStats[i][4] < self.parent.flightStats[0][4]: # Flight Min latitude
                    self.parent.flightStats[0][4] = self.parent.flightStats[i][4]
                if self.parent.flightStats[i][5] < self.parent.flightStats[0][5]: # Flight Min longitude
                    self.parent.flightStats[0][5] = self.parent.flightStats[i][5]
                if self.parent.flightStats[i][6] > self.parent.flightStats[0][6]: # Flight Max latitude
                    self.parent.flightStats[0][6] = self.parent.flightStats[i][6]
                if self.parent.flightStats[i][7] > self.parent.flightStats[0][7]: # Flight Max longitude
                    self.parent.flightStats[0][7] = self.parent.flightStats[i][7]
                if self.parent.flightStats[i][8] > self.parent.flightStats[0][8]: # Vertical Max speed (could be up or down)
                    self.parent.flightStats[0][8] = self.parent.flightStats[i][8]
                self.parent.flightStats[0][9] = self.parent.flightStats[0][9] + self.parent.flightStats[i][9] # Total Distance Travelled


class DreamerBaseLogParser():

    def __init__(self, parent):
        self.parent = parent

    def parse(self, importRef):
        # TODO - port over from app version 1.4.2
        print("Not yet implemented.")

